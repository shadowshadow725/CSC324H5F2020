#lang racket

#| CSC324 Fall 2020: Exercise 4 |#

;-------------------------------------------------------------------------------
(provide calculate eval-calc)

;-------------------------------------------------------------------------------
; * Task 1: Eager Evaluation *
;-------------------------------------------------------------------------------

#|
(calculate expr)
  expr: A datum representing an expression generated by the
        grammar in the Exericse 4 handout
|#
(define (calculate expr)
  (eval-calc expr (hash)))

#|
(eval-calc expr env)
  expr: A datum representing an expression generated by the
        grammar in the Exercise 4 handout
  env:  A hash table representing an environment.
        The keys of the hash table are symbols representing identifiers.

  You may assume that if an `expr` is an identifier, then it is present in `env`.
|#
(define/match (eval-calc expr env)
  ;[((list '(list 'lambda args expr) x ...  ) env) ('123)]
  [((list (list 'lambda '() expr) ) env ) ( eval-calc expr env)]
  [((list '+ x y) env) ( + (eval-calc x env) (eval-calc y env))]
  [((list '- x y) env) ( - (eval-calc x env) (eval-calc y env))]
  [((list '* x y) env) ( * (eval-calc x env) (eval-calc y env))]
  [((list '/ x y) env) ( / (eval-calc x env) (eval-calc y env))]
  [(x 0) x]
  [(expr env)  (if  (or (and (and (list? expr)  (>  (length expr) 1) ) (< (length expr ) 3))   (and (and (list? expr) (list? (first expr))) (eq? (first (first expr )) 'lambda )  ))

                    (if (eq? (first (first expr )) 'lambda )
                       ( if (eq? (length (list-ref (first expr) 1 )) 0)
                            (eval-calc (list-ref expr 1) env)
                            (eval-calc   (append (list (list 'lambda (rest (list-ref (first expr) 1)) (list-ref (first expr) 2) )) (list-tail expr 2)) 

                                        (hash-set env (first (list-ref (first expr) 1)) (list-ref expr 1))
                                        )
                        )

                       ((first expr) (eval-calc (list-ref expr 1)  env) (eval-calc (list-ref expr 2 ) 0))
                       )
                  
                 
                  (if (number? expr)
                      expr

                      (if (symbol? expr)

                          (hash-ref env expr)
                          (if ( and (list? expr) ( symbol? (first expr )))
                              (if (>= (length (list-ref expr 1 ) ) 1)

                              ( eval-calc (list 'let*  (rest(list-ref expr 1 )) (list-ref expr 2 ))

                                          (hash-set env  (list-ref (list-ref (list-ref expr 1) 0) 0)  (eval-calc (list-ref (list-ref (list-ref expr 1) 0) 1) env ) ))
                              (eval-calc (list-ref expr 2) env)
                              )
                              
                               (hash-ref env expr)
                              )
                          )
                   
                   )

                      )
               ]
  


  )

(module+ test
  (require rackunit)
  ; You should write more tests to make sure that your
  ; interpreter uses lexical scoping

  (test-equal? "Function definition"
               (calculate '((lambda (a) (+ a 1)) 4))
             5)
  (test-equal? "Functions with multiple arguments"
               (calculate '((lambda (a b) (+ b 1)) 4 14))
               15)
  
  

)
