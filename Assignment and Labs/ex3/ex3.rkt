#lang racket #| CSC324 Fall 2019: Exercise 3 |#
#|
* Before starting, please review the exercise guidelines at
http://www.cs.toronto.edu/~lczhang/324/assignments.html *
|#
;-------------------------------------------------------------------------------
(provide calculate eval-calc)


;-------------------------------------------------------------------------------
; * Task 1 and 2: Using and Building an environment *
;-------------------------------------------------------------------------------

#|
(calculate expr)
  expr: A datum representing an expression generated by the
        Expanded Binary Arithmetic Expression Grammar in the handout

  Calls the function `eval-calc` with an empty environment.
  You do not need to modify this function.
|#
(define (calculate expr)
  (eval-calc expr (hash)))

#|
(eval-calc expr env)
  expr: A datum representing an expression generated by the
        Expanded Binary Arithmetic Expression Grammar in the handout
  env:  A hash table representing an environment.
        The keys of the hash table are symbols representing identifiers.

  You may assume that if an `expr` is an identifier, then it is present in `env`.

  Relevant documentation:
    https://docs.racket-lang.org/reference/hashtables.html
    (look up `hash-ref`, `hash-set`, and `hash`)

  In Racket, the function `hash-set` takes a hash table, a new key-value pair,
  and returns a *new* hash table with all the elements in the old hash table,
  plus the new key-value pair.
|#
(define/match (eval-calc expr env)
  [((list '+ x y) env) ( + (eval-calc x env) (eval-calc y env))]
  [((list '- x y) env) ( - (eval-calc x env) (eval-calc y env))]
  [((list '* x y) env) ( * (eval-calc x env) (eval-calc y env))]
  [((list '/ x y) env) ( / (eval-calc x env) (eval-calc y env))]
  [(x 0) x]
  [(expr env)  (if (and (and (list? expr)  (>  (length expr) 1) ) (< (length expr ) 3))
                  ((first expr) (eval-calc (list-ref expr 1)  env) (eval-calc (list-ref expr 2 ) 0))
                  (if (number? expr)
                      expr
                   (if ( and (list? expr) ( symbol? (first expr )))
                              (if (>= (length (list-ref expr 1 ) ) 1)

                              ( eval-calc (list 'let*  (rest(list-ref expr 1 )) (list-ref expr 2 ))

                                          (hash-set env  (list-ref (list-ref (list-ref expr 1) 0) 0)  (eval-calc (list-ref (list-ref (list-ref expr 1) 0) 1) env ) ))
                              (eval-calc (list-ref expr 2) env)
                              )
                               (hash-ref env expr)
                              )
                   )

                      )
               ]
  )

(module+ test
  (require rackunit)
   ;Task 2 tests
  (test-equal? "Environment lookup {a: 1}"
               (eval-calc 'a (hash 'a 1))
               1)
 (test-equal? "Environment lookup {a: 3}"
              (eval-calc '(+ a 1) (hash 'a 3))
               4)
  (test-equal? "Environment lookup {a: 2, b: 20}"
               (eval-calc '(+ a (* b 2)) (hash 'a 2 'b 20))
               42)

  
  ; Task 3 tests
  (test-equal? "Let* binding {a: 3}"
              (calculate '(let* ((a 3)) (+ a 1)))
               4)
  (test-equal? "Multiple binding {a: 3, b: 4}"
               (calculate '(let* ((a 3) (b 4)) (+ a b)))
               7)
  (test-equal? "Recursive bindings"
               (calculate '(let* ((a 3) (a (+ a 1))) (* a 2)))
               8)
  )

